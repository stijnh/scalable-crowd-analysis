import numpy as np
import random
import scipy.cluster.hierarchy
import scipy.spatial

from collections import defaultdict
from heapq import heappush, heappop


def build_tracklets(trajectories, window):
    """
    Generate list of tracklets from 2D trajectories. Each tracklet is a 4-tuple
    (x, y, vx, vy) indicating position (x, y) and velocity vector (vx, vy)

    :param trajectories: List of trajectories. Each trajectory must be a list of (x, y) tuples.
    :param window: Window size used for tracklet generation.
    :returns: Tuple (ids, tracklets).
    """
    ids = []
    tracklets = []

    A = []
    for dt in range(-window, window+1):
        A.append((1, 0, dt, 0))
        A.append((0, 1, 0, dt))

    for index,trajectory in enumerate(trajectories):
        n = len(trajectory)

        for i in range(window, n - window):
            B = []

            for dt in range(-window, window+1):
                B.append(trajectory[i + dt][0])
                B.append(trajectory[i + dt][1])

            result = np.linalg.lstsq(A, B)[0]

            ids.append((index, i))
            tracklets.append(result)

    return np.array(ids), np.array(tracklets)


def prepare_quick_shift(tracklets):
    """
    Calculates ``rho``, ``delta``, and ``parent`` for each tracklet. Needed for 
    quick-shift procedure.

     * ``rho[i]`` is the 'density' for tracklet ``i``
     * ``parent[i]`` is closest tracklet having higher density. As a special case,
       ``parent[i] == i`` if ``rho[i]`` is the global maximum.
     * ``delta[i]`` is the distance between tracklet ``i`` and ``parent[i]``.

    :param tracklets: Tracklets generated by ``generate_tracklets``
    :returns: Tuple ``(rho, delta, parent)``
    """
    max_radius = 10
    rho = []
    delta = []
    parent = []

    p = tracklets[:,[0,1]] # Position
    v = tracklets[:,[2,3]] # Velocity

    n = len(tracklets)
    tree = scipy.spatial.cKDTree(tracklets)

    def get_neighbors(i, radius):
        neighbors = np.array(tree.query_ball_point(tracklets[i], radius))

        dist_p = np.linalg.norm(p[i] - p[neighbors], axis=1)
        dist_v = np.linalg.norm(v[i] - v[neighbors], axis=1)
        dist = np.maximum(dist_p, dist_v)

        indices = dist < radius
        return neighbors[indices], dist[indices]

    for i in range(n):
        neighbors,_ = get_neighbors(i, 1.0)

        density = np.sum(np.linalg.norm(v[neighbors], axis=1))
        rho.append(density)


    rho = np.array(rho)
    max_rho = np.amax(rho)

    for i in range(n):
        radius = 0.1
        q = i

        if rho[i] < max_rho:
            while True:
                neighbors, dists = get_neighbors(i, radius)
                valid = rho[neighbors] > rho[i]

                if np.any(valid):
                    index = np.argmin(np.where(valid, dists, float('inf')))

                    q = neighbors[index]
                    radius = dists[index]
                    break
                elif radius > max_radius or len(neighbors) == n:
                    break
                else:
                    radius *= 2
        else:
            radius = max_radius

        delta.append(radius)
        parent.append(q)

    delta = np.array(delta)
    parent = np.array(parent)

    return rho, delta, parent


def perform_quick_shift(rho, delta, parent, min_rho=0, max_delta=1):
    """
    Perform quick-shift procedure. 

    :param rho: Generated by ``prepare_quick_shift``.
    :param delta: Generated by ``prepare_quick_shift``.
    :param parent: Generated by ``prepare_quick_shift``.
    :param min_rho: Tracklets having ``rho[i] < min_rho`` are considered noise.
    :param max_delta: Tracklets having ``delta[i] > max_delta`` are considered
    cluster centers
    :returns: Tuple ``(labels, centers)``. ``labels`` stores the cluster label
    for each tracklet where ``labels[i] == -1`` indicate noise. ``centers`` stores
    the list of indices indicating the tracklets which are centers.
    """
    roots = np.nonzero(delta > max_delta)[0]

    parent = parent.copy()
    parent[roots] = roots

    centers = roots[rho[roots] > min_rho]
    np.random.shuffle(centers)

    labels = np.full(len(rho), -1, dtype=np.int32)
    labels[centers] = np.arange(len(centers))

    while True:
        old_labels = labels
        labels = labels[parent]

        if np.all(old_labels == labels):
            break

    return labels, centers


def calculate_cohesion(ids, labels, gamma, samples=25):
    """
    Calculate cohesion matrix required for ``merge_cohesion``.

    :param ids: Tracklet identifiers from ``generate_tracklets``.
    :param labels: Tracklet cluster labels from ``perform_quick_shift``.
    :param gamma: Temporal influence between tracklets.
    :param samples: Number of samples per tracklets for calculating cohesion.
    :returns: Cohesion matrix.
    """
    n = len(ids)
    k = int(np.amax(labels) + 1)
    sim = np.zeros((k, k))

    for i in range(len(ids)):
        for j in i + np.random.geometric(1 - gamma, samples):
            if j >= n: continue               # Out of bounds.
            if ids[i,0] != ids[j,0]: continue # Different node.
            if labels[i] == -1: continue      # Noise tracklet.
            if labels[j] == -1: continue      # Noise tracklet.
            sim[labels[i],labels[j]] += 1.0 / samples

    return sim


def merge_cohesion(labels, sim, cut=None):
    """
    Perform hierarchical clustering.

    :param labels: Tracklet cluster labels from ``perform_quick_shift``.
    :param sim: Cohesion matrix from ``caclculate_cohesion``.
    :param cut: The height at which to cut the dendrogram, or ``None`` to
    not cut the tree.
    :returns: Tuple ``(labels, joins)``. ``labels`` stores the cluster label
    for each tracklet where ``label[i] == -1`` indicate noise. ``joins``
    is the list mergers performed during the hierarchical process. Each joins
    is a 4-tuple ``(s, i, j, k)`` indicating that cluster ``i`` and cluster ``j``
    where merged to create cluster ``k`` having cohesion score ``s``.
    """
    n = len(sim)
    volume = defaultdict(lambda: 0)
    cross = defaultdict(lambda: 0)
    joins = []
    parent = [i for i in range(n)]
    valid = set(range(n))
    heap = []

    def calc_score(i, j):
        return 1 + \
                (cross[i,i] + cross[j,j] + cross[i,j] + cross[j,i]) / (volume[i] + volume[j]) \
                - cross[i,i] / volume[i] \
                - cross[j,j] / volume[j]

    for v,l in enumerate(labels):
        if l != -1:
            volume[l] += 1.0

    for i in range(n):
        for j in range(n):
            cross[i,j] = sim[i,j]

    for i,j in cross.keys():
        score = calc_score(i, j)
        heappush(heap, (-score, i, j))

    finished = False

    while heap:
        s,i,j = heappop(heap)
        s *= -1

        if i == j: continue
        if i not in valid: continue
        if j not in valid: continue

        if cut is not None and s < cut:
            finished = True

        k = len(parent)
        joins.append((s, i, j, k))
        volume[k] = volume[i] + volume[j]

        valid.add(k)
        valid.remove(i)
        valid.remove(j)

        parent.append(k)
        if not finished:
            parent[i] = k
            parent[j] = k

        cross[k,k] = cross[i,i] + cross[j,j] + cross[i,j] + cross[j,i]

        for l in valid:
            if l == k: continue
            cross[k,l] = cross[i,l] + cross[j,l]
            cross[l,k] = cross[l,i] + cross[l,j]
            score = calc_score(k, l)
            heappush(heap, (-score, k, l))


    for i,j in enumerate(parent):
        while parent[j] != j:
            j = parent[j]
        parent[i] = j

    labels = [(parent[l] if l != -1 else -1) for l in labels]

    return np.array(labels), np.array(joins)


def plot_delta_rho(axis, rho, delta):
    """
    Plots delta-rho values using matplotlib.
    """
    rho_max = np.amax(rho)

    axis.scatter(rho, delta, s=1)
    axis.set_xlim(0, rho_max)
    axis.set_ylim(0, 10)
    axis.set_xlabel('Density')
    axis.set_ylabel('Distance')


def plot_joins(axis, joins):
    """
    Plot dendrogram using joins from ``merge_cohesion``.
    """

    import matplotlib.ticker as ticker
    @ticker.FuncFormatter
    def formatter(x, pos):
        return str(1-x)

    Z = []

    for s, i, j, k in joins:
        Z.append((i, j, max(1-s, 0), 0))

    if len(Z):
        scipy.cluster.hierarchy.dendrogram(
                Z,
                color_threshold=1000,
                ax=axis)
    axis.set_ylabel('Similarity')
    axis.yaxis.set_major_formatter(formatter)
